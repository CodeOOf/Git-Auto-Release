name: CI/CD Pipeline with Semantic Versioning

on:
  push:
    branches:
      - '**'  # All branches
  pull_request:
    branches:
      - main
      - alpha
      - release

jobs:
  # Policy check: Ensure no direct commits to main
  policy-check:
    name: Policy Validation
    runs-on: ubuntu-latest
    if: github.ref_name == 'main' && github.event_name == 'push'
    continue-on-error: true
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2
      
      - name: Check for direct commits to main
        run: |
          # Check if this is a merge commit (has 2 parents)
          if git rev-parse HEAD^2 &>/dev/null; then
            echo "‚úÖ This is a merge commit (allowed)"
            exit 0
          fi
          
          # Check if commit message contains PR number (squash merge)
          COMMIT_MSG=$(git log -1 --pretty=%B)
          if echo "$COMMIT_MSG" | grep -qE '\(#[0-9]+\)|#[0-9]+'; then
            echo "‚úÖ This is a squash merge from PR (allowed)"
            exit 0
          fi
          
          # This is a direct commit to main
          echo "‚ùå POLICY VIOLATION: Direct commit to main detected"
          echo "‚ö†Ô∏è  All changes to main must go through PRs from feature/bugfix/alpha/beta branches"
          echo "‚ö†Ô∏è  Direct commits to main are NOT ALLOWED"
          echo ""
          echo "üìù Commit message: $COMMIT_MSG"
          echo "üë§ Commit author: $(git log -1 --pretty=format:'%an <%ae>')"
          echo ""
          echo "::error::POLICY VIOLATION: Direct commit to main is not allowed"
          exit 1

  # Calculate version based on branch and commit
  version:
    name: Calculate Version
    runs-on: ubuntu-latest
    needs: [policy-check]
    if: always()
    permissions:
      contents: read
      pull-requests: read
    outputs:
      version: ${{ steps.semver.outputs.version }}
      tag: ${{ steps.semver.outputs.tag }}
      is_release: ${{ steps.semver.outputs.is_release }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for version calculation
      
      - name: Install jq for JSON parsing
        run: |
          if ! command -v jq &> /dev/null; then
            sudo apt-get update && sudo apt-get install -y jq
          fi
      
      - name: Read base version
        id: base_version
        run: |
          if [ -f VERSION ]; then
            echo "version=$(cat VERSION)" >> $GITHUB_OUTPUT
          else
            echo "version=0.1.0" >> $GITHUB_OUTPUT
          fi
      
      - name: Calculate semantic version
        id: semver
        run: |
          BASE_VERSION="${{ steps.base_version.outputs.version }}"
          # For PRs, use the source branch (head ref), otherwise use current branch
          if [ -n "${{ github.event.pull_request.head.ref }}" ]; then
            BRANCH_NAME="${{ github.event.pull_request.head.ref }}"
          else
            BRANCH_NAME="${{ github.ref_name }}"
          fi
          SHORT_SHA="${GITHUB_SHA:0:8}"
          PR_NUMBER="${{ github.event.pull_request.number }}"
          PR_SOURCE="${{ github.event.pull_request.head.ref }}"
          PR_TARGET="${{ github.event.pull_request.base.ref }}"
          
          # Debug output
          echo "üîç Event: ${{ github.event_name }}"
          echo "üîç PR_SOURCE: ${PR_SOURCE:-empty}"
          echo "üîç BRANCH_NAME: ${BRANCH_NAME}"
          
          # Extract version components (handle pre-release suffixes like -alpha, -beta, -rc)
          # Remove any suffix after - or + to get base X.Y.Z
          CLEAN_VERSION="${BASE_VERSION%%-*}"
          CLEAN_VERSION="${CLEAN_VERSION%%+*}"
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CLEAN_VERSION"
          
          # Extract pre-release suffix if exists (e.g., -alpha, -beta, -rc)
          if [[ "$BASE_VERSION" =~ -([a-zA-Z]+) ]]; then
            BASE_SUFFIX="-${BASH_REMATCH[1]}"
          else
            BASE_SUFFIX=""
          fi
          
          # Determine version based on branch strategy and PR context
          # For PRs, check the target branch; for pushes, check the current branch
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            TARGET_BRANCH="${PR_TARGET}"
          else
            TARGET_BRANCH="${BRANCH_NAME}"
          fi
          
          case "$TARGET_BRANCH" in
            release)
              if [ "${{ github.event_name }}" = "pull_request" ]; then
                # PR to release: vX.Y.Z-rc.N (release candidate)
                RC_COUNT=$(git tag -l "v${MAJOR}.${MINOR}.${PATCH}-rc.*" | wc -l)
                RC_NUM=$((RC_COUNT + 1))
                VERSION="${MAJOR}.${MINOR}.${PATCH}-rc.${RC_NUM}"
                TAG=""
                IS_RELEASE="false"
              else
                # Push to release after PR merge: Clean version
                VERSION="${MAJOR}.${MINOR}.${PATCH}"
                TAG="v${VERSION}"
                IS_RELEASE="true"
              fi
              ;;
            main)
              if [ "${{ github.event_name }}" = "pull_request" ]; then
                # PR to main: Calculate version for validation
                # Use BRANCH_NAME as fallback if PR_SOURCE is empty
                SOURCE_BRANCH="${PR_SOURCE:-$BRANCH_NAME}"
                echo "üîç Source branch for PR: ${SOURCE_BRANCH}"
                
                case "$SOURCE_BRANCH" in
                  alpha)
                    # Merge from alpha = MAJOR bump
                    NEXT_MAJOR=$((MAJOR + 1))
                    VERSION="${NEXT_MAJOR}.0.0-alpha"
                    ;;
                  feature/*)
                    # Merge from feature = MINOR bump (unless in major alpha/beta)
                    # Check if we're in major alpha release (VERSION = X.0.0-alpha)
                    if [[ "$BASE_VERSION" =~ ^[0-9]+\.0\.0-alpha ]]; then
                      # Major alpha: show current VERSION+SHA for PR (strip .N suffix)
                      CLEAN_VERSION="${BASE_VERSION%.*}"  # Remove .N if present
                      VERSION="${CLEAN_VERSION}+${SHORT_SHA}"
                    # Check if we're in major beta release (VERSION = X.0.0-beta)
                    elif [[ "$BASE_VERSION" =~ ^[0-9]+\.0\.0-beta ]]; then
                      # Major beta: show current VERSION+SHA for PR (strip .N suffix)
                      CLEAN_VERSION="${BASE_VERSION%.*}"  # Remove .N if present
                      VERSION="${CLEAN_VERSION}+${SHORT_SHA}"
                    else
                      # Regular development: MINOR bump (same as merge result)
                      NEXT_MINOR=$((MINOR + 1))
                      VERSION="${MAJOR}.${NEXT_MINOR}.0-beta"
                    fi
                    ;;
                  bugfix/*)
                    # Merge from bugfix = PATCH bump or .N increment during major alpha/beta
                    # Check if we're in major alpha release (VERSION = X.0.0-alpha)
                    if [[ "$BASE_VERSION" =~ ^[0-9]+\.0\.0-alpha ]]; then
                      # Major alpha: show current VERSION+SHA for PR (strip .N suffix)
                      CLEAN_VERSION="${BASE_VERSION%.*}"  # Remove .N if present
                      VERSION="${CLEAN_VERSION}+${SHORT_SHA}"
                    # Check if we're in major beta release (VERSION = X.0.0-beta)
                    elif [[ "$BASE_VERSION" =~ ^[0-9]+\.0\.0-beta ]]; then
                      # Major beta: show current VERSION+SHA for PR (strip .N suffix)
                      CLEAN_VERSION="${BASE_VERSION%.*}"  # Remove .N if present
                      VERSION="${CLEAN_VERSION}+${SHORT_SHA}"
                    else
                      # Regular development: show preview version (no PATCH bump yet)
                      BUGFIX_COUNT=$(git log --oneline --grep="^fix" --grep="^bugfix" origin/main..HEAD | wc -l)
                      BUGFIX_NUM=$((BUGFIX_COUNT > 0 ? BUGFIX_COUNT : 1))
                      VERSION="${MAJOR}.${MINOR}.${PATCH}-bugfix.${BUGFIX_NUM}"
                    fi
                    ;;
                  beta)
                    # Merge from beta (already has bumped MAJOR version)
                    VERSION="${MAJOR}.${MINOR}.${PATCH}-beta"
                    ;;
                  *)
                    # Default
                    VERSION="${MAJOR}.${MINOR}.${PATCH}-beta"
                    ;;
                esac
                TAG=""
                IS_RELEASE="false"
              else
                # Push to main after PR merge: Detect bump from merge commit or squash merge
                BRANCH_TYPE=""
                
                if git rev-parse HEAD^2 &>/dev/null; then
                  # This is a merge commit (has 2 parents)
                  MERGE_COMMIT_PARENT=$(git rev-parse HEAD^2)
                  echo "üîç Merge commit detected, checking parent: $MERGE_COMMIT_PARENT"
                  
                  # Check which branches contain this commit
                  # The source branch should contain the second parent
                  BRANCHES_WITH_COMMIT=$(git branch -r --contains "$MERGE_COMMIT_PARENT" 2>/dev/null || echo "")
                  echo "üîç Branches containing commit: $BRANCHES_WITH_COMMIT"
                  
                  # Check if commit came from alpha
                  if echo "$BRANCHES_WITH_COMMIT" | grep -q "origin/alpha"; then
                    BRANCH_TYPE="alpha"
                    echo "‚úÖ Detected alpha branch from merge commit"
                  # Check if commit came from beta
                  elif echo "$BRANCHES_WITH_COMMIT" | grep -q "origin/beta"; then
                    BRANCH_TYPE="beta"
                    echo "‚úÖ Detected beta branch from merge commit"
                  # Check if commit came from feature/*
                  elif echo "$BRANCHES_WITH_COMMIT" | grep -q "origin/feature/"; then
                    BRANCH_TYPE="feature"
                    echo "‚úÖ Detected feature/* branch from merge commit"
                  # Check if commit came from bugfix/*
                  elif echo "$BRANCHES_WITH_COMMIT" | grep -q "origin/bugfix/"; then
                    BRANCH_TYPE="bugfix"
                    echo "‚úÖ Detected bugfix/* branch from merge commit"
                  fi
                else
                  echo "üîç Not a merge commit (squash merge), will use API fallback"
                fi
                
                # If not a merge commit or branch not found, check for squash merge via API
                if [ -z "$BRANCH_TYPE" ]; then
                  MERGE_COMMIT_MSG=$(git log -1 --pretty=%B)
                  echo "üìù Merge commit message: $MERGE_COMMIT_MSG"
                  
                  # Try multiple PR number extraction patterns
                  PR_NUMBER=$(echo "$MERGE_COMMIT_MSG" | grep -oP '\(#\K[0-9]+(?=\))' || echo "")
                  if [ -z "$PR_NUMBER" ]; then
                    PR_NUMBER=$(echo "$MERGE_COMMIT_MSG" | grep -oP '#\K[0-9]+' | head -1 || echo "")
                  fi
                  
                  if [ -n "$PR_NUMBER" ]; then
                    echo "üîç Detected PR #${PR_NUMBER}, querying GitHub API for source branch..."
                    PR_INFO=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                      "https://api.github.com/repos/${{ github.repository }}/pulls/$PR_NUMBER")
                    
                    # Check if API call was successful
                    if echo "$PR_INFO" | grep -q '"message".*"Resource not accessible'; then
                      echo "‚ùå API access denied. Workflow requires 'pull-requests: read' permission"
                      echo "üîç PR API response: $(echo "$PR_INFO" | head -c 200)"
                      echo "‚ùå Cannot determine source branch type without API access"
                    else
                      # Debug: Show PR info head
                      echo "üîç PR API response (first 500 chars): $(echo "$PR_INFO" | head -c 500)"
                      
                      # Extract head ref (source branch)
                      LAST_PR_BRANCH=$(echo "$PR_INFO" | jq -r '.head.ref' 2>/dev/null || echo "")
                      
                      # Fallback to grep if jq fails
                      if [ -z "$LAST_PR_BRANCH" ] || [ "$LAST_PR_BRANCH" = "null" ]; then
                        LAST_PR_BRANCH=$(echo "$PR_INFO" | grep -oP '"ref":\s*"\K[^"]+' | head -1)
                      fi
                      
                      echo "üîç Extracted source branch: '${LAST_PR_BRANCH}'"
                      
                      if [[ "$LAST_PR_BRANCH" == "alpha" ]]; then
                        BRANCH_TYPE="alpha"
                      elif [[ "$LAST_PR_BRANCH" == "beta" ]]; then
                        BRANCH_TYPE="beta"
                      elif [[ "$LAST_PR_BRANCH" =~ ^feature/ ]]; then
                        BRANCH_TYPE="feature"
                      elif [[ "$LAST_PR_BRANCH" =~ ^bugfix/ ]]; then
                        BRANCH_TYPE="bugfix"
                      fi
                      
                      echo "‚úÖ Source branch from API: ${LAST_PR_BRANCH} -> type: ${BRANCH_TYPE}"
                    fi
                  else
                    echo "‚ö†Ô∏è  Could not extract PR number from commit message"
                  fi
                fi
                
                if [ -z "$BRANCH_TYPE" ]; then
                  # Could not determine branch type - create build version
                  echo "‚ö†Ô∏è  Could not determine source branch type"
                  echo ""
                  echo "üìù Commit message: $MERGE_COMMIT_MSG"
                  if [ -n "$PR_NUMBER" ]; then
                    echo "üîç PR number detected: #${PR_NUMBER}"
                    echo "‚ùå Possible causes:"
                    echo "   1. Workflow lacks 'pull-requests: read' permission"
                    echo "   2. Source branch was deleted before workflow ran"
                    echo "   3. PR information not accessible"
                  fi
                  echo ""
                  echo "‚ö†Ô∏è  Creating build version"
                  VERSION="${BASE_VERSION}+${SHORT_SHA}"
                  TAG=""
                  IS_RELEASE="false"
                else
                  case "$BRANCH_TYPE" in
                  alpha)
                    # Merged from alpha = MAJOR bump automatically
                    NEXT_MAJOR=$((MAJOR + 1))
                    VERSION="${NEXT_MAJOR}.0.0-alpha"
                    TAG="v${VERSION}"
                    ;;
                  feature)
                    # Merged from feature = MINOR bump (unless in major alpha/beta)
                    # Check if we're in major alpha release (VERSION = X.0.0-alpha)
                    if [[ "$BASE_VERSION" =~ ^[0-9]+\.0\.0-alpha ]]; then
                      # Major alpha: increment build metadata
                      if [[ "$BASE_VERSION" =~ \.([0-9]+)$ ]]; then
                        CURRENT_BUILD="${BASH_REMATCH[1]}"
                        NEXT_BUILD=$((CURRENT_BUILD + 1))
                      else
                        NEXT_BUILD="1"
                      fi
                      VERSION="${MAJOR}.${MINOR}.${PATCH}-alpha.${NEXT_BUILD}"
                      TAG="v${VERSION}"
                    # Check if we're in major beta release (VERSION = X.0.0-beta)
                    elif [[ "$BASE_VERSION" =~ ^[0-9]+\.0\.0-beta ]]; then
                      # Major beta: increment build metadata
                      if [[ "$BASE_VERSION" =~ \.([0-9]+)$ ]]; then
                        CURRENT_BUILD="${BASH_REMATCH[1]}"
                        NEXT_BUILD=$((CURRENT_BUILD + 1))
                      else
                        NEXT_BUILD="1"
                      fi
                      VERSION="${MAJOR}.${MINOR}.${PATCH}-beta.${NEXT_BUILD}"
                      TAG="v${VERSION}"
                    else
                      # Regular beta or no beta: MINOR bump
                      NEXT_MINOR=$((MINOR + 1))
                      VERSION="${MAJOR}.${NEXT_MINOR}.0-beta"
                      TAG="v${VERSION}"
                    fi
                    ;;
                  bugfix)
                    # Merged from bugfix = PATCH bump or .N increment during major alpha/beta
                    # Check if we're in major alpha release (VERSION = X.0.0-alpha)
                    if [[ "$BASE_VERSION" =~ ^[0-9]+\.0\.0-alpha ]]; then
                      # Major alpha: increment build metadata
                      if [[ "$BASE_VERSION" =~ \.([0-9]+)$ ]]; then
                        CURRENT_BUILD="${BASH_REMATCH[1]}"
                        NEXT_BUILD=$((CURRENT_BUILD + 1))
                      else
                        NEXT_BUILD="1"
                      fi
                      VERSION="${MAJOR}.${MINOR}.${PATCH}-alpha.${NEXT_BUILD}"
                      TAG="v${VERSION}"
                    # Check if we're in major beta release (VERSION = X.0.0-beta)
                    elif [[ "$BASE_VERSION" =~ ^[0-9]+\.0\.0-beta ]]; then
                      # Major beta: increment build metadata
                      if [[ "$BASE_VERSION" =~ \.([0-9]+)$ ]]; then
                        CURRENT_BUILD="${BASH_REMATCH[1]}"
                        NEXT_BUILD=$((CURRENT_BUILD + 1))
                      else
                        NEXT_BUILD="1"
                      fi
                      VERSION="${MAJOR}.${MINOR}.${PATCH}-beta.${NEXT_BUILD}"
                      TAG="v${VERSION}"
                    elif [[ "$BASE_VERSION" =~ -beta ]]; then
                      # Regular beta (not major): PATCH bump with -beta suffix
                      NEXT_PATCH=$((PATCH + 1))
                      VERSION="${MAJOR}.${MINOR}.${NEXT_PATCH}-beta"
                      TAG="v${VERSION}"
                    elif [[ "$BASE_VERSION" =~ -alpha ]]; then
                      # Regular beta (not major): PATCH bump with -beta suffix
                      NEXT_PATCH=$((PATCH + 1))
                      VERSION="${MAJOR}.${MINOR}.${NEXT_PATCH}-beta"
                    elif [[ "$BASE_VERSION" =~ -alpha ]]; then
                      # Extract existing build number if present
                      if [[ "$BASE_VERSION" =~ \.([0-9]+)$ ]]; then
                        CURRENT_BUILD="${BASH_REMATCH[1]}"
                        NEXT_BUILD=$((CURRENT_BUILD + 1))
                      else
                        NEXT_BUILD="1"
                      fi
                      VERSION="${MAJOR}.${MINOR}.${PATCH}-alpha.${NEXT_BUILD}"
                      TAG="v${VERSION}"
                    else
                      # Not in beta/alpha phase, do PATCH bump
                      NEXT_PATCH=$((PATCH + 1))
                      VERSION="${MAJOR}.${MINOR}.${NEXT_PATCH}-beta"
                      TAG="v${VERSION}"
                    fi
                    ;;
                  beta)
                    # Merged from beta (already bumped major version in alpha merge)
                    # Just add -beta suffix to current version
                    VERSION="${MAJOR}.${MINOR}.${PATCH}-beta"
                    TAG="v${VERSION}"
                    ;;
                  *)
                    # Default
                    VERSION="${MAJOR}.${MINOR}.${PATCH}-beta"
                    TAG="v${VERSION}"
                    ;;
                  esac
                  IS_RELEASE="false"
                fi
              fi
              ;;
            alpha)
              # Alpha branch: vX.Y.Z+SHA (current VERSION from main, before major bump)
              VERSION="${MAJOR}.${MINOR}.${PATCH}+${SHORT_SHA}"
              TAG=""
              IS_RELEASE="false"
              ;;
            beta)
              # Beta branch (created from main after alpha merge): vX.Y.Z-alpha+SHA
              # VERSION file should already be X.Y.Z-alpha at this point
              VERSION="${MAJOR}.${MINOR}.${PATCH}-alpha+${SHORT_SHA}"
              TAG=""
              IS_RELEASE="false"
              ;;
            feature/*)
              # Feature branch: vX.Y.Z+SHA (current VERSION from main, for all pushes and PRs)
              VERSION="${MAJOR}.${MINOR}.${PATCH}+${SHORT_SHA}"
              TAG=""
              IS_RELEASE="false"
              ;;
            bugfix/*)
              # Bugfix branch: vX.Y.Z+SHA (current VERSION from main, for all pushes and PRs)
              VERSION="${MAJOR}.${MINOR}.${PATCH}+${SHORT_SHA}"
              TAG=""
              IS_RELEASE="false"
              ;;
            hotfix)
              if [ "${{ github.event_name }}" = "pull_request" ]; then
                # PR from hotfix to release: vX.Y.Z+1-rc.N (PATCH bump)
                NEXT_PATCH=$((PATCH + 1))
                RC_COUNT=$(git tag -l "v${MAJOR}.${MINOR}.${NEXT_PATCH}-rc.*" | wc -l)
                RC_NUM=$((RC_COUNT + 1))
                VERSION="${MAJOR}.${MINOR}.${NEXT_PATCH}-rc.${RC_NUM}"
              else
                # Hotfix branch push: vX.Y.Z-hotfix.N
                HOTFIX_COUNT=$(git tag -l "v${MAJOR}.${MINOR}.${PATCH}-hotfix.*" | wc -l)
                HOTFIX_NUM=$((HOTFIX_COUNT + 1))
                VERSION="${MAJOR}.${MINOR}.${PATCH}-hotfix.${HOTFIX_NUM}"
              fi
              TAG=""
              IS_RELEASE="false"
              ;;
            *)
              # Other branches: vX.Y.Z+SHA
              VERSION="${MAJOR}.${MINOR}.${PATCH}+${SHORT_SHA}"
              TAG=""
              IS_RELEASE="false"
              ;;
          esac
          
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "tag=${TAG}" >> $GITHUB_OUTPUT
          echo "is_release=${IS_RELEASE}" >> $GITHUB_OUTPUT
          
          echo "üì¶ Calculated version: ${VERSION}"
          echo "üè∑Ô∏è  Tag: ${TAG:-none}"
          echo "üöÄ Is release: ${IS_RELEASE}"
          echo "üîç PR Source: ${PR_SOURCE:-N/A}"
          echo "üéØ Branch: ${BRANCH_NAME}"

  # Build and test (runs on all branches except release)
  build:
    name: Build & Test
    runs-on: ubuntu-latest
    needs: version
    if: github.ref_name != 'release'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Display version
        run: |
          echo "üèóÔ∏è  Building version: ${{ needs.version.outputs.version }}"
          echo "üìã This is a template project - customize the build job with your project's commands"
      
      - name: Placeholder - Setup your environment
        run: |
          echo "Add your environment setup here"
          # Example for Node.js: 
          #   uses: actions/setup-node@v4
          #   with:
          #     node-version: '20'
          # Example for Python:
          #   uses: actions/setup-python@v5
          #   with:
          #     python-version: '3.11'
      
      - name: Placeholder - Install dependencies
        run: |
          echo "Add your dependency installation here"
          # Example for Node.js: npm ci
          # Example for Python: pip install -r requirements.txt
          # Example for Go: go mod download
      
      - name: Placeholder - Build
        run: |
          echo "Add your build commands here"
          echo "Version to use: ${{ needs.version.outputs.version }}"
          # Example for Node.js: npm run build
          # Example for Python: python setup.py build
          # Example for Go: go build -ldflags "-X main.Version=${{ needs.version.outputs.version }}"
        env:
          VERSION: ${{ needs.version.outputs.version }}
      
      - name: Placeholder - Run tests
        run: |
          echo "Add your test commands here"
          # Example for Node.js: npm test
          # Example for Python: pytest
          # Example for Go: go test ./...
      
      - name: Placeholder - Upload artifacts (optional)
        run: |
          echo "Optionally upload build artifacts"
          # Uncomment and customize as needed:
          # - name: Upload artifacts
          #   uses: actions/upload-artifact@v4
          #   with:
          #     name: build-artifacts-${{ needs.version.outputs.version }}
          #     path: dist/
          #     retention-days: 30

  # EXAMPLE: Build and publish Docker images (commented out - uncomment and customize for your project)
  # docker:
  #   name: Build & Publish Docker
  #   runs-on: ubuntu-latest
  #   needs: [version, build]
  #   if: |
  #     (github.ref_name == 'main' || github.ref_name == 'release') && 
  #     github.event_name == 'push'
  #   
  #   steps:
  #     - name: Checkout code
  #       uses: actions/checkout@v4
  #     
  #     - name: Set up Docker Buildx
  #       uses: docker/setup-buildx-action@v3
  #     
  #     - name: Login to Docker Hub
  #       uses: docker/login-action@v3
  #       with:
  #         username: ${{ secrets.DOCKER_USERNAME }}
  #         password: ${{ secrets.DOCKER_PASSWORD }}
  #     
  #     - name: Build and push
  #       uses: docker/build-push-action@v5
  #       with:
  #         context: .
  #         file: ./Dockerfile
  #         push: true
  #         tags: |
  #           ${{ secrets.DOCKER_USERNAME }}/your-image:${{ needs.version.outputs.version }}
  #           ${{ secrets.DOCKER_USERNAME }}/your-image:latest
  #         build-args: |
  #           VERSION=${{ needs.version.outputs.version }}

  # Create GitHub release and tag (release branch only)
  release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: [version]
    if: github.ref_name == 'release' && github.event_name == 'push'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Create Git tag
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "${{ needs.version.outputs.tag }}" -m "Release ${{ needs.version.outputs.tag }}"
          git push origin "${{ needs.version.outputs.tag }}"
      
      - name: Generate changelog
        id: changelog
        run: |
          PREVIOUS_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
          if [ -n "$PREVIOUS_TAG" ]; then
            CHANGELOG=$(git log ${PREVIOUS_TAG}..HEAD --pretty=format:"- %s (%h)" --no-merges)
          else
            CHANGELOG=$(git log --pretty=format:"- %s (%h)" --no-merges)
          fi
          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGELOG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.version.outputs.tag }}
          name: Release ${{ needs.version.outputs.tag }}
          body: |
            ## Release ${{ needs.version.outputs.tag }}
            
            ### Changes
            
            ${{ steps.changelog.outputs.changelog }}
            
            ---
            
            **Built:** ${{ github.event.head_commit.timestamp }}  
            **Commit:** ${{ github.sha }}  
            **Branch:** ${{ github.ref_name }}
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Sync to main
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git fetch origin main
          git checkout main
          git merge origin/release --no-ff -m "chore: sync release ${{ needs.version.outputs.tag }} to main"
          git push origin main

  # Automatically update VERSION file after successful merges
  update-version:
    name: Update VERSION File
    runs-on: ubuntu-latest
    needs: [version, build]
    if: |
      github.event_name == 'push' && 
      (github.ref_name == 'main' || github.ref_name == 'release') &&
      needs.version.outputs.tag != '' &&
      github.event.head_commit.message != '' &&
      !contains(github.event.head_commit.message, '[skip ci]')
    permissions:
      contents: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Check if merge commit or squash merge
        id: check_merge
        run: |
          # Check if this is a merge commit (has 2 parents)
          if git rev-parse HEAD^2 &>/dev/null; then
            echo "is_merge=true" >> $GITHUB_OUTPUT
            echo "merge_type=merge" >> $GITHUB_OUTPUT
            echo "‚úÖ This is a merge commit (2 parents)"
          else
            # Check if this is a squash merge by looking for PR number
            COMMIT_MSG=$(git log -1 --pretty=%B)
            if [[ "$COMMIT_MSG" =~ \(#[0-9]+\) ]]; then
              echo "is_merge=true" >> $GITHUB_OUTPUT
              echo "merge_type=squash" >> $GITHUB_OUTPUT
              echo "‚úÖ This is a squash merge (PR found in commit message)"
            else
              echo "is_merge=false" >> $GITHUB_OUTPUT
              echo "merge_type=none" >> $GITHUB_OUTPUT
              echo "‚ÑπÔ∏è  This is a direct commit, skipping VERSION update"
            fi
          fi
      
      - name: Update VERSION file
        id: update_version
        if: steps.check_merge.outputs.is_merge == 'true'
        run: |
          CALCULATED_VERSION="${{ needs.version.outputs.version }}"
          CURRENT_VERSION=$(cat VERSION)
          
          # Determine new VERSION content based on branch and calculated version
          if [ "${{ github.ref_name }}" = "release" ]; then
            # On release: Use calculated version (may include -rc temporarily, then clean on final push)
            NEW_VERSION="${CALCULATED_VERSION}"
            # If this is the final production release (no -rc), strip all suffixes
            if [[ ! "$NEW_VERSION" =~ -rc ]]; then
              NEW_VERSION="${NEW_VERSION%%-*}"
              NEW_VERSION="${NEW_VERSION%%+*}"
              echo "üìù Release branch: Setting VERSION to ${NEW_VERSION} (clean production version)"
            else
              echo "üìù Release branch: Setting VERSION to ${NEW_VERSION} (includes -rc during merge)"
            fi
          elif [ "${{ github.ref_name }}" = "main" ]; then
            # On main: use the tagged version (includes -alpha or -beta suffix)
            NEW_VERSION="${{ needs.version.outputs.tag }}"
            NEW_VERSION="${NEW_VERSION#v}"  # Remove 'v' prefix
            echo "üìù Main branch: Setting VERSION to ${NEW_VERSION}"
          fi
          
          # Only update if VERSION changed
          if [ "$CURRENT_VERSION" != "$NEW_VERSION" ]; then
            echo "$NEW_VERSION" > VERSION
            
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git add VERSION
            git commit -m "chore: auto-update VERSION to ${NEW_VERSION} [skip ci]"
            git push origin ${{ github.ref_name }}
            
            echo "‚úÖ VERSION updated from ${CURRENT_VERSION} to ${NEW_VERSION}"
            echo "version_updated=true" >> $GITHUB_OUTPUT
          else
            echo "‚ÑπÔ∏è  VERSION unchanged (${CURRENT_VERSION})"
            echo "version_updated=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Create Git tag
        if: steps.check_merge.outputs.is_merge == 'true' && github.ref_name == 'main' && steps.update_version.outputs.version_updated == 'true'
        run: |
          TAG="${{ needs.version.outputs.tag }}"
          if [ -n "$TAG" ]; then
            # Pull the latest commit (the VERSION update) to ensure tag points to it
            git pull origin ${{ github.ref_name }}
            
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git tag -a "$TAG" -m "Pre-release $TAG"
            git push origin "$TAG"
            echo "‚úÖ Created and pushed tag: $TAG (on VERSION update commit)"
          else
            echo "‚ÑπÔ∏è  No tag to create"
          fi

  # Summary
  summary:
    name: Build Summary
    runs-on: ubuntu-latest
    needs: [version, build]
    if: always()
    
    steps:
      - name: Display summary
        run: |
          echo "## Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Version:** ${{ needs.version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Build Status:** ${{ needs.build.result }}" >> $GITHUB_STEP_SUMMARY
          if [ -n "${{ needs.version.outputs.tag }}" ]; then
            echo "- **Tag:** ${{ needs.version.outputs.tag }}" >> $GITHUB_STEP_SUMMARY
          fi

  # Sync branches when main is updated (e.g., from hotfix fast-forward)
  sync_branches:
    name: Sync Branches with Main
    runs-on: ubuntu-latest
    needs: [version, build, update-version]
    if: |
      github.ref_name == 'main' && 
      github.event_name == 'push' &&
      !contains(github.event.head_commit.message, '[skip ci]')
    permissions:
      contents: write  # Required to create and push beta branch
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
      
      - name: Check if merge commit or squash merge
        id: check_merge
        run: |
          # Check if this is a merge commit (has 2 parents)
          if git rev-parse HEAD^2 &>/dev/null; then
            echo "is_merge=true" >> $GITHUB_OUTPUT
            echo "‚úÖ This is a merge commit (2 parents)"
          else
            # Check if this is a squash merge by looking for PR number
            COMMIT_MSG=$(git log -1 --pretty=%B)
            if [[ "$COMMIT_MSG" =~ \(#[0-9]+\) ]]; then
              echo "is_merge=true" >> $GITHUB_OUTPUT
              echo "‚úÖ This is a squash merge (PR found in commit message)"
            else
              echo "is_merge=false" >> $GITHUB_OUTPUT
              echo "‚ÑπÔ∏è  This is a direct commit, skipping branch sync"
            fi
          fi
      
      - name: Create beta branch if needed
        if: steps.check_merge.outputs.is_merge == 'true'
        run: |
          # Check if beta branch exists
          if ! git ls-remote --heads origin beta | grep -q beta; then
            # Check if VERSION has -alpha suffix (indicating alpha was just merged)
            # Use the calculated version from the version job, not the VERSION file
            CALCULATED_VERSION="${{ needs.version.outputs.version }}"
            echo "üìã Calculated version from workflow: $CALCULATED_VERSION"
            
            if [[ "$CALCULATED_VERSION" =~ -alpha ]]; then
              echo "üåø Creating beta branch from main (alpha was just merged)"
              git checkout -b beta
              git push origin beta
              echo "‚úÖ Beta branch created successfully"
            else
              echo "‚ÑπÔ∏è  No -alpha suffix in calculated version, beta branch not needed yet"
            fi
          else
            echo "‚ÑπÔ∏è  Beta branch already exists"
          fi
          
          # Return to main
          git checkout main
      
      - name: Sync active branches
        if: steps.check_merge.outputs.is_merge == 'true'
        run: |
          echo "üîÑ Checking for branches that need to sync with main..."
          
          # Get all remote branches
          git fetch --all
          
          # List of branch patterns to sync
          BRANCH_PATTERNS=("alpha" "beta" "feature/*" "bugfix/*")
          SYNCED_COUNT=0
          
          for pattern in "${BRANCH_PATTERNS[@]}"; do
            # Find matching branches
            if [ "$pattern" = "alpha" ] || [ "$pattern" = "beta" ]; then
              # Check if exact branch exists
              if git ls-remote --heads origin "$pattern" | grep -q "$pattern"; then
                BRANCHES=("$pattern")
              else
                BRANCHES=()
              fi
            else
              # Find branches matching pattern (e.g., feature/*)
              BRANCHES=($(git ls-remote --heads origin "$pattern" | awk -F'/' '{print $NF}' | sed "s|^|${pattern%/*}/|"))
            fi
            
            for branch in "${BRANCHES[@]}"; do
              if [ -n "$branch" ]; then
                echo "üì¶ Syncing branch: $branch"
                
                # Checkout the branch
                git checkout -b "$branch" "origin/$branch" 2>/dev/null || git checkout "$branch"
                git pull origin "$branch"
                
                # Check if main has commits not in this branch
                BEHIND_COUNT=$(git rev-list --count HEAD..origin/main)
                
                if [ "$BEHIND_COUNT" -gt 0 ]; then
                  echo "  ‚Ü≥ Branch is $BEHIND_COUNT commits behind main, fast-forwarding..."
                  
                  # Attempt fast-forward merge
                  if git merge --ff-only origin/main; then
                    git push origin "$branch"
                    echo "  ‚úÖ Successfully synced $branch with main"
                    SYNCED_COUNT=$((SYNCED_COUNT + 1))
                  else
                    echo "  ‚ö†Ô∏è  Cannot fast-forward $branch (has diverged). Manual merge required."
                  fi
                else
                  echo "  ‚úì Branch is up to date with main"
                fi
                
                # Return to main
                git checkout main
              fi
            done
          done
          
          echo ""
          echo "üìä Sync Summary: $SYNCED_COUNT branch(es) synchronized with main"
